
##Automate Infrastructure With IAC Using Terraform Part 2##

Continuing from where we have stopped in Project 16.

Create a private subnet using the code snippet as found in the image below

![2  private subnet](https://user-images.githubusercontent.com/79456052/200909175-aed6f2f0-bad0-4ec6-b841-be81aa9024c1.png)

![2a  subnet](https://user-images.githubusercontent.com/79456052/200947442-53738473-6eae-4e11-8980-a49d150c5f32.png)

Declare the variables used in the private subnet code snippet

![3  enter the following variables in the variables file](https://user-images.githubusercontent.com/79456052/200911028-aa30d7fb-ef48-4ca3-b59a-bd45ab72eb15.png)

Input the codes in the image below into the terraform tfvars file

![4  4  and edit the tfvars files to include tag](https://user-images.githubusercontent.com/79456052/200911542-8c1ecd49-c866-448d-80c6-53c9d523bd52.png)

The Internet gateway, the Nat gateway and the elastic ip are the next set of resources to be created. the use of depends_on in the code snippet for the elastic ip and the nat gateway indicates that the Internet Gateway resource must be available before the nat gateway and the elastic ip resources.

![6a  internet gateway](https://user-images.githubusercontent.com/79456052/200947655-dec65949-b888-459a-9c1a-565bdfbe675f.png)

![5a  nat gateway](https://user-images.githubusercontent.com/79456052/200947758-32a859a9-d487-4882-909e-6bc2d7cdac6f.png)

input the commands below inside the variables.tf file

![9  variable declared for environmebt](https://user-images.githubusercontent.com/79456052/200949166-f40653bd-a822-421c-90a9-0c79b5ba3368.png)

also add the codes below in the terraform.tfvars file

![10  environment declaration for tfvars](https://user-images.githubusercontent.com/79456052/200949241-398a7150-355e-4b69-a4b6-9f45957e73d2.png)

run the terraform plan command to confirm there are no errors

Create a file called route_tables.tf and use it to create routes  route tables and route table associations for both public and private subnets.

```# create private route table
resource "aws_route_table" "private-rtb" {
  vpc_id = aws_vpc.main.id

  tags = merge(
    var.tags,
    {
      Name = format("%s-Private-Route-Table", var.name)
    },
  )
}

# create route for the private route table and attatch a nat gateway to it
resource "aws_route" "private-rtb-route" {
  route_table_id         = aws_route_table.private-rtb.id
  destination_cidr_block = "0.0.0.0/0"
  gateway_id             = aws_nat_gateway.nat.id
}

# associate all private subnets to the private route table
resource "aws_route_table_association" "private-subnets-assoc" {
  count          = length(aws_subnet.private[*].id)
  subnet_id      = element(aws_subnet.private[*].id, count.index)
  route_table_id = aws_route_table.private-rtb.id
}

# create route table for the public subnets
resource "aws_route_table" "public-rtb" {
  vpc_id = aws_vpc.main.id

  tags = merge(
    var.tags,
    {
      Name = format("%s-Public-Route-Table", var.name)
    },
  )
}

# create route for the public route table and attach the internet gateway
resource "aws_route" "public-rtb-route" {
  route_table_id         = aws_route_table.public-rtb.id
  destination_cidr_block = "0.0.0.0/0"
  gateway_id             = aws_internet_gateway.ig.id
}

# associate all public subnets to the public route table
resource "aws_route_table_association" "public-subnets-assoc" {
  count          = length(aws_subnet.public[*].id)
  subnet_id      = element(aws_subnet.public[*].id, count.index)
  route_table_id = aws_route_table.public-rtb.id
}
```

Run the *terraform plan and terraform apply --auto-approve* commands and confirm that the VPC, 2 public subnet, 4 proivate subnets, 1 internet Gateway, 1 NAT Gateway, 1 EIP and 2 Route tables  esources have been added in multip-az  set up.

Create a cert.tf file for the AWS certification manager and add the code snippet below into it.

```# The entire section create a certiface, public zone, and validate the certificate using DNS method

# Create the certificate using a wildcard for all the domains created in lamislick.click
resource "aws_acm_certificate" "lamislick" {
  domain_name       = "*.lamislick.click"
  validation_method = "DNS"
}

# calling the hosted zone
data "aws_route53_zone" "lamislick" {
  name         = "lamislick.click"
  private_zone = false
}

# selecting validation method
resource "aws_route53_record" "lamislick" {
  for_each = {
    for dvo in aws_acm_certificate.lamislick.domain_validation_options : dvo.domain_name => {
      name   = dvo.resource_record_name
      record = dvo.resource_record_value
      type   = dvo.resource_record_type
    }
  }

  allow_overwrite = true
  name            = each.value.name
  records         = [each.value.record]
  ttl             = 60
  type            = each.value.type
  zone_id         = data.aws_route53_zone.lamislick.zone_id
}

# validate the certificate through DNS method
resource "aws_acm_certificate_validation" "lamislick" {
  certificate_arn         = aws_acm_certificate.lamislick.arn
  validation_record_fqdns = [for record in aws_route53_record.lamislick : record.fqdn]
}

# create records for tooling
resource "aws_route53_record" "tooling" {
  zone_id = data.aws_route53_zone.lamislick.zone_id
  name    = "tooling.lamislick.click"
  type    = "A"

  alias {
    name                   = aws_lb.ext-alb.dns_name
    zone_id                = aws_lb.ext-alb.zone_id
    evaluate_target_health = true
  }
}


# create records for wordpress
resource "aws_route53_record" "wordpress" {
  zone_id = data.aws_route53_zone.lamislick.zone_id
  name    = "wordpress.lamislick.click"
  type    = "A"

  alias {
    name                   = aws_lb.ext-alb.dns_name
    zone_id                = aws_lb.ext-alb.zone_id
    evaluate_target_health = true
  }
}
```

Create all the security groups and security group rules in a single file called security.tf, and add the code below into the security file. 

```# The entire section create a certiface, public zone, and validate the certificate using DNS method

# Create the certificate using a wildcard for all the domains created in lamislick.click
resource "aws_acm_certificate" "lamislick" {
  domain_name       = "*.lamislick.click"
  validation_method = "DNS"
}

# calling the hosted zone
data "aws_route53_zone" "lamislick" {
  name         = "lamislick.click"
  private_zone = false
}

# selecting validation method
resource "aws_route53_record" "lamislick" {
  for_each = {
    for dvo in aws_acm_certificate.lamislick.domain_validation_options : dvo.domain_name => {
      name   = dvo.resource_record_name
      record = dvo.resource_record_value
      type   = dvo.resource_record_type
    }
  }

  allow_overwrite = true
  name            = each.value.name
  records         = [each.value.record]
  ttl             = 60
  type            = each.value.type
  zone_id         = data.aws_route53_zone.lamislick.zone_id
}

# validate the certificate through DNS method
resource "aws_acm_certificate_validation" "lamislick" {
  certificate_arn         = aws_acm_certificate.lamislick.arn
  validation_record_fqdns = [for record in aws_route53_record.lamislick : record.fqdn]
}

# create records for tooling
resource "aws_route53_record" "tooling" {
  zone_id = data.aws_route53_zone.lamislick.zone_id
  name    = "tooling.lamislick.click"
  type    = "A"

  alias {
    name                   = aws_lb.ext-alb.dns_name
    zone_id                = aws_lb.ext-alb.zone_id
    evaluate_target_health = true
  }
}


# create records for wordpress
resource "aws_route53_record" "wordpress" {
  zone_id = data.aws_route53_zone.lamislick.zone_id
  name    = "wordpress.lamislick.click"
  type    = "A"

  alias {
    name                   = aws_lb.ext-alb.dns_name
    zone_id                = aws_lb.ext-alb.zone_id
    evaluate_target_health = true
  }
}
```

















