
##Automate Infrastructure With IAC Using Terraform Part 2##

Continuing from where we have stopped in Project 16.

Create a private subnet using the code snippet as found in the image below

![2  private subnet](https://user-images.githubusercontent.com/79456052/200909175-aed6f2f0-bad0-4ec6-b841-be81aa9024c1.png)

![2a  subnet](https://user-images.githubusercontent.com/79456052/200947442-53738473-6eae-4e11-8980-a49d150c5f32.png)

Declare the variables used in the private subnet code snippet

![3  enter the following variables in the variables file](https://user-images.githubusercontent.com/79456052/200911028-aa30d7fb-ef48-4ca3-b59a-bd45ab72eb15.png)

Input the codes in the image below into the terraform tfvars file

![4  4  and edit the tfvars files to include tag](https://user-images.githubusercontent.com/79456052/200911542-8c1ecd49-c866-448d-80c6-53c9d523bd52.png)

The Internet gateway, the Nat gateway and the elastic ip are the next set of resources to be created. the use of depends_on in the code snippet for the elastic ip and the nat gateway indicates that the Internet Gateway resource must be available before the nat gateway and the elastic ip resources.

![6a  internet gateway](https://user-images.githubusercontent.com/79456052/200947655-dec65949-b888-459a-9c1a-565bdfbe675f.png)

![5a  nat gateway](https://user-images.githubusercontent.com/79456052/200947758-32a859a9-d487-4882-909e-6bc2d7cdac6f.png)

input the commands below inside the variables.tf file

![9  variable declared for environmebt](https://user-images.githubusercontent.com/79456052/200949166-f40653bd-a822-421c-90a9-0c79b5ba3368.png)

also add the codes below in the terraform.tfvars file

![10  environment declaration for tfvars](https://user-images.githubusercontent.com/79456052/200949241-398a7150-355e-4b69-a4b6-9f45957e73d2.png)

run the terraform plan command to confirm there are no errors

Create a file called route_tables.tf and use it to create routes  route tables and route table associations for both public and private subnets.

```# create private route table
resource "aws_route_table" "private-rtb" {
  vpc_id = aws_vpc.main.id

  tags = merge(
    var.tags,
    {
      Name = format("%s-Private-Route-Table", var.name)
    },
  )
}

# create route for the private route table and attatch a nat gateway to it
resource "aws_route" "private-rtb-route" {
  route_table_id         = aws_route_table.private-rtb.id
  destination_cidr_block = "0.0.0.0/0"
  gateway_id             = aws_nat_gateway.nat.id
}

# associate all private subnets to the private route table
resource "aws_route_table_association" "private-subnets-assoc" {
  count          = length(aws_subnet.private[*].id)
  subnet_id      = element(aws_subnet.private[*].id, count.index)
  route_table_id = aws_route_table.private-rtb.id
}

# create route table for the public subnets
resource "aws_route_table" "public-rtb" {
  vpc_id = aws_vpc.main.id

  tags = merge(
    var.tags,
    {
      Name = format("%s-Public-Route-Table", var.name)
    },
  )
}

# create route for the public route table and attach the internet gateway
resource "aws_route" "public-rtb-route" {
  route_table_id         = aws_route_table.public-rtb.id
  destination_cidr_block = "0.0.0.0/0"
  gateway_id             = aws_internet_gateway.ig.id
}

# associate all public subnets to the public route table
resource "aws_route_table_association" "public-subnets-assoc" {
  count          = length(aws_subnet.public[*].id)
  subnet_id      = element(aws_subnet.public[*].id, count.index)
  route_table_id = aws_route_table.public-rtb.id
}
```

Run the *terraform plan and terraform apply --auto-approve* commands and confirm that the VPC, 2 public subnet, 4 proivate subnets, 1 internet Gateway, 1 NAT Gateway, 1 EIP and 2 Route tables  esources have been added in multip-az  set up.

Create a cert.tf file for the AWS certification manager and add the code snippet below into it.

```# The entire section create a certiface, public zone, and validate the certificate using DNS method

# Create the certificate using a wildcard for all the domains created in lamislick.click
resource "aws_acm_certificate" "lamislick" {
  domain_name       = "*.lamislick.click"
  validation_method = "DNS"
}

# calling the hosted zone
data "aws_route53_zone" "lamislick" {
  name         = "lamislick.click"
  private_zone = false
}

# selecting validation method
resource "aws_route53_record" "lamislick" {
  for_each = {
    for dvo in aws_acm_certificate.lamislick.domain_validation_options : dvo.domain_name => {
      name   = dvo.resource_record_name
      record = dvo.resource_record_value
      type   = dvo.resource_record_type
    }
  }

  allow_overwrite = true
  name            = each.value.name
  records         = [each.value.record]
  ttl             = 60
  type            = each.value.type
  zone_id         = data.aws_route53_zone.lamislick.zone_id
}

# validate the certificate through DNS method
resource "aws_acm_certificate_validation" "lamislick" {
  certificate_arn         = aws_acm_certificate.lamislick.arn
  validation_record_fqdns = [for record in aws_route53_record.lamislick : record.fqdn]
}

# create records for tooling
resource "aws_route53_record" "tooling" {
  zone_id = data.aws_route53_zone.lamislick.zone_id
  name    = "tooling.lamislick.click"
  type    = "A"

  alias {
    name                   = aws_lb.ext-alb.dns_name
    zone_id                = aws_lb.ext-alb.zone_id
    evaluate_target_health = true
  }
}


# create records for wordpress
resource "aws_route53_record" "wordpress" {
  zone_id = data.aws_route53_zone.lamislick.zone_id
  name    = "wordpress.lamislick.click"
  type    = "A"

  alias {
    name                   = aws_lb.ext-alb.dns_name
    zone_id                = aws_lb.ext-alb.zone_id
    evaluate_target_health = true
  }
}
```

Create all the security groups and security group rules in a single file called security.tf, and add the code below into the security file. 

```# The entire section create a certiface, public zone, and validate the certificate using DNS method

# Create the certificate using a wildcard for all the domains created in lamislick.click
resource "aws_acm_certificate" "lamislick" {
  domain_name       = "*.lamislick.click"
  validation_method = "DNS"
}

# calling the hosted zone
data "aws_route53_zone" "lamislick" {
  name         = "lamislick.click"
  private_zone = false
}

# selecting validation method
resource "aws_route53_record" "lamislick" {
  for_each = {
    for dvo in aws_acm_certificate.lamislick.domain_validation_options : dvo.domain_name => {
      name   = dvo.resource_record_name
      record = dvo.resource_record_value
      type   = dvo.resource_record_type
    }
  }

  allow_overwrite = true
  name            = each.value.name
  records         = [each.value.record]
  ttl             = 60
  type            = each.value.type
  zone_id         = data.aws_route53_zone.lamislick.zone_id
}

# validate the certificate through DNS method
resource "aws_acm_certificate_validation" "lamislick" {
  certificate_arn         = aws_acm_certificate.lamislick.arn
  validation_record_fqdns = [for record in aws_route53_record.lamislick : record.fqdn]
}

# create records for tooling
resource "aws_route53_record" "tooling" {
  zone_id = data.aws_route53_zone.lamislick.zone_id
  name    = "tooling.lamislick.click"
  type    = "A"

  alias {
    name                   = aws_lb.ext-alb.dns_name
    zone_id                = aws_lb.ext-alb.zone_id
    evaluate_target_health = true
  }
}


# create records for wordpress
resource "aws_route53_record" "wordpress" {
  zone_id = data.aws_route53_zone.lamislick.zone_id
  name    = "wordpress.lamislick.click"
  type    = "A"

  alias {
    name                   = aws_lb.ext-alb.dns_name
    zone_id                = aws_lb.ext-alb.zone_id
    evaluate_target_health = true
  }
}
```


Create an External Load balancer(internet facing) to balance traffic betwen the instances in an alb.tf file followed by a target group which points the External load balancers to its targets, and a listener for the target group. An internal Load balancer (internal facing) is also created in the same file, with its own target group and listners for the target group.

```# ----------------------------
#External Load balancer for reverse proxy nginx
#---------------------------------

resource "aws_lb" "ext-alb" {
  name     = "ext-alb"
  internal = false
  security_groups = [
    aws_security_group.ext-alb-sg.id,
  ]

  subnets = [
    aws_subnet.public[0].id,
    aws_subnet.public[1].id
  ]

  tags = merge(
    var.tags,
    {
      Name = "ACS-ext-alb"
    },
  )

  ip_address_type    = "ipv4"
  load_balancer_type = "application"
}

#--- create a target group for the external load balancer
resource "aws_lb_target_group" "nginx-tgt" {
  health_check {
    interval            = 10
    path                = "/healthstatus"
    protocol            = "HTTPS"
    timeout             = 5
    healthy_threshold   = 5
    unhealthy_threshold = 2
  }
  name        = "nginx-tgt"
  port        = 443
  protocol    = "HTTPS"
  target_type = "instance"
  vpc_id      = aws_vpc.main.id
}

#--- create a listener for the load balancer

resource "aws_lb_listener" "nginx-listner" {
  load_balancer_arn = aws_lb.ext-alb.arn
  port              = 443
  protocol          = "HTTPS"
  certificate_arn   = aws_acm_certificate_validation.lamislick.certificate_arn

  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.nginx-tgt.arn
  }
}



# ----------------------------
#Internal Load Balancers for webservers
#---------------------------------

resource "aws_lb" "ialb" {
  name     = "ialb"
  internal = true
  security_groups = [
    aws_security_group.int-alb-sg.id,
  ]

  subnets = [
    aws_subnet.private[0].id,
    aws_subnet.private[1].id
  ]

  tags = merge(
    var.tags,
    {
      Name = "ACS-int-alb"
    },
  )

  ip_address_type    = "ipv4"
  load_balancer_type = "application"
}


# --- target group  for wordpress -------

resource "aws_lb_target_group" "wordpress-tgt" {
  health_check {
    interval            = 10
    path                = "/healthstatus"
    protocol            = "HTTPS"
    timeout             = 5
    healthy_threshold   = 5
    unhealthy_threshold = 2
  }

  name        = "wordpress-tgt"
  port        = 443
  protocol    = "HTTPS"
  target_type = "instance"
  vpc_id      = aws_vpc.main.id
}


# --- target group for tooling -------

resource "aws_lb_target_group" "tooling-tgt" {
  health_check {
    interval            = 10
    path                = "/healthstatus"
    protocol            = "HTTPS"
    timeout             = 5
    healthy_threshold   = 5
    unhealthy_threshold = 2
  }

  name        = "david-tooling-tgt"
  port        = 443
  protocol    = "HTTPS"
  target_type = "instance"
  vpc_id      = aws_vpc.main.id
}

# For this aspect a single listener was created for the wordpress which is default,
# A rule was created to route traffic to tooling when the host header changes


resource "aws_lb_listener" "web-listener" {
  load_balancer_arn = aws_lb.ialb.arn
  port              = 443
  protocol          = "HTTPS"
  certificate_arn   = aws_acm_certificate_validation.lamislick.certificate_arn


  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.wordpress-tgt.arn
  }
}

# listener rule for tooling target

resource "aws_lb_listener_rule" "tooling-listener" {
  listener_arn = aws_lb_listener.web-listener.arn
  priority     = 99

  action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.tooling-tgt.arn
  }

  condition {
    host_header {
      values = ["tooling.lamislick.click"]
    }
  }
}
```

We want to pass an IAM role our EC2 instances to give them access to some specific resources, so we need to do the following:

1. Create AssumeRole
2. Create IAM policy for this role
3. Attach the Policy to the IAM Role
4. Create an Instance Profile and interpolate the IAM Role
 
Create a roles.tf file and copy the code snippets into the file to achieve the IAM roles and policies for the instances

```resource "aws_iam_role" "ec2_instance_role" {
  name = "ec2_instance_role"
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Sid    = ""
        Principal = {
          Service = "ec2.amazonaws.com"
        }
      },
    ]
  })
  tags = merge(
    var.tags,
    {
      Name = "aws assume role"
    },
  )
}

resource "aws_iam_policy" "policy" {
  name        = "ec2_instance_policy"
  description = "A test policy"
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = [
          "ec2:Describe*",
        ]
        Effect   = "Allow"
        Resource = "*"
      },
    ]

  })

  tags = merge(
    var.tags,
    {
      Name = "aws assume policy"
    },
  )
}

resource "aws_iam_role_policy_attachment" "test-attach" {
  role       = aws_iam_role.ec2_instance_role.name
  policy_arn = aws_iam_policy.policy.arn
}

resource "aws_iam_instance_profile" "ip" {
  name = "aws_instance_profile_test"
  role = aws_iam_role.ec2_instance_role.name
}
```

















